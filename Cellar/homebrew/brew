#!/usr/bin/ruby
# Copyright 2009 Max Howell <max@methylblue.com>
# Licensed as per the GPL version 3
require 'find'
require 'pathname'
$root = Pathname.new(__FILE__).realpath.dirname.parent.parent

def prune
  n=0
  dirs=Array.new
  $root.find do |path|
    if path.directory?
      name=path.relative_path_from($root).to_s
      if name == '.git' or name == 'Cellar' or name == 'Formula'
        Find.prune
      else
        dirs<<path
      end
    elsif path.symlink?
      resolved_path=path.dirname+path.readlink
      unless resolved_path.exist?
        path.unlink
        n+=1
      end
    end
  end
  # entries lists '.' and '..' so 2 is minimum basically
  dirs.sort.reverse_each { |d| d.rmdir if d.children.length == 0 }
  return n
end

case ARGV[0]
  when 'brew', 'install' then
    abort "You must specify a Formula" unless ARGV[1]
    ARGV.shift
    file="#{$root}/Formula/#{ARGV.shift}"
    file+='.rb' unless File.exist? file
    system "ruby #{file} #{ARGV.join ' '}"

  when 'rm', 'uninstall' then
    path=$root+'Cellar'+ARGV[1]
    abort "#{ARGV[1]} is not installed" unless path.directory?
    path.rmtree
    prune
    puts "#{path} removed"

  when 'ln' then
    target=Pathname.new(ARGV[1])
    target=$root+'Cellar'+target unless target.exist?

    abort "#{target} is not a directory" unless target.directory?

    target=target.realpath

    if target.parent.parent == $root
      # we are one dir too high
      kids=target.children
      abort "#{target} is empty :(" if kids.length == 0
      abort "There are multiple versions of #{target.basename} installed please specify one" if kids.length > 1
      target=target.children.first
      abort "#{target} is not a directory!" unless target.directory?
    elsif target.parent.parent.parent != $root
      abort '#{target} is not a keg'
    end

    #TODO you should mkdirs as you find them and symlink files otherwise
    #TODO consider using hardlinks

    n=0
    target.find do |from|
      next if from == ARGV[1] #rubysucks

      to=$root+from.relative_path_from(target)

      if from.directory?
        to.mkpath unless to.exist?
      elsif from.file?
        tod=to.dirname
        Dir.chdir(tod) do
          `ln -sf "#{from.relative_path_from tod}"`
          n+=1
        end
      end
    end
    puts "Created #{n} links"

  when 'abv', 'stats', 'statistics'
    cellar=$root+'Cellar'
    print `find #{cellar} -type f | wc -l`.strip+' files, '+`du -hd0 #{cellar} | cut -d"\t" -f1`.strip

  when 'prune', 'pasteurize' then
    puts "Pruned #{prune} files"

  when 'prefix'
    # Get the clean path to $prefix/Cellar/homebrew/brew/../../../
    # Don't resolve any symlinks of that final result.
    # Rationale: if the user calls /usr/local/bin/brew but that will resolve
    # to /Brewery/Cellar/homebrew/brew we should give /usr/local and not
    # /Brewery because the user probably has chosen /usr/local as the Homebrew
    # to expose to the system.
    if File.symlink? __FILE__
      # using pathname as it will handle readlink returning abs or rel paths
      d=Pathname.new(__FILE__).dirname
      puts File.expand_path(d+File.readlink(__FILE__)+'../../../')
    else
      # Dir.pwd resolves the symlink :P #rubysucks
      # we use the cwd because __FILE__ can be relative and expand_path 
      # resolves the symlink for the working directory if fed a relative path
      # SIGH
      cwd=Pathname.new `pwd`.strip
      puts File.expand_path(cwd+__FILE__+'../../../')
    end

  when 'cache'
    puts File.expand_path('~/Library/Application Support/Homebrew')

  else
    puts "usage: #{$0} [prune] [ln path] [install pkg]"
end