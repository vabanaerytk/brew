#!/usr/bin/ruby
require 'find'
require 'pathname'
$:.unshift Pathname.new(__FILE__).dirname.parent.realpath+'Library'+'Homebrew'
require 'env'

# often causes Ruby to throw exception ffs
Dir.chdir '/' unless File.directory? ENV['PWD']

######################################################################## funcs
def prune
  n=0
  dirs=Array.new
  $root.find do |path|
    if path.directory?
      name=path.relative_path_from($root).to_s
      if name == '.git' or name == 'Cellar' or name == 'Library'
        Find.prune
      else
        dirs<<path
      end
    elsif path.symlink?
      resolved_path=path.dirname+path.readlink
      unless resolved_path.exist?
        path.unlink
        n+=1
      end
    end
  end
  dirs.sort.reverse_each do |d|
    if d.children.length == 0
      d.rmdir
      n+=1
    end
  end
  return n
end

# we actually remove formulae from ARGV so that any other analysis of ARGV
# only includes relevent arguments
# TODO require will throw if no formula, so we should catch no?
def extract_named_args
  args=Array.new
  ARGV.delete_if do |arg|
    if arg[0,1] == '-'
      false
    else
      args<<arg
      true
    end
  end
  return args
end

def extract_kegs
  require 'keg'
  kegs=extract_named_args.collect {|name| Keg.new name}
  raise "Expecting the name of a keg or formula, eg:\n\tbrew #{ARGV.join ' '} wget" if kegs.empty?
  return kegs
end

def abv keg=nil
  path=keg ? keg.path : $cellar
  if path.directory?
    `find #{path} -type f | wc -l`.strip+' files, '+`du -hd0 #{path} | cut -d"\t" -f1`.strip
  else
    nil
  end
end

def install formula
  require 'keg'

  raise "#{formula.name} already installed!\n\t#{formula.prefix}" if formula.installed?
  
  beginning = Time.now

  formula.brew do
    if ARGV.include? '--interactive'
      ohai "Entering interactive mode"
      puts "Type `exit' to return and finalize the installation"
      puts "Install to this prefix: #{formula.prefix}"
      pid=fork
      if pid.nil?
        exec 'bash'
      else
        Process.wait pid
      end
    elsif ARGV.include? '--help'
      ohai './configure --help'
      puts `./configure --help`
      exit
    else
      formula.prefix.mkpath
      formula.install
      %w[README ChangeLog COPYING COPYRIGHT AUTHORS].each do |file|
        formula.prefix.install file if File.file? file
      end
    end
  end
  ohai 'Finishing up'
  keg=Keg.new formula
  keg.clean
  keg.ln
  if formula.caveats
    ohai "Caveats"
    puts formula.caveats
    ohai "Summary"
  end
  puts "#{keg.path}: "+abv(keg)+", built in #{pretty_duration Time.now-beginning}"
rescue Exception
  formula.prefix.rmtree
  raise
end

def mk url
  require 'formula'
  path=Pathname.new(url)

  /(.*?)[-_.]?#{path.version}/.match path.basename
  raise "Couldn't parse name from #{url}" if $1.nil? or $1.empty?

  path=Formula.path $1
  raise "#{path} already exists!" if File.exist? path

  f=File.new path, 'w'
  f.puts "require 'brewkit'"
  f.puts
  f.puts "class #{Formula.class $1} <Formula"
  f.puts "  @url='#{url}'"
  f.puts "  @homepage=''" # second because you fill in these two first
  f.puts "  @md5=''"
  f.puts
  f.puts "  def install"
  f.puts "    system \"./configure --disable-debug --prefix='\#{prefix}'\""
  f.puts "    system \"make install\""
  f.puts "  end"
  f.print "end"
  f.close

  return path
end

def prefix
  Pathname.new(__FILE__).dirname.parent.expand_path
end

def usage
  name=File.basename $0
  <<-EOS
Usage: #{name} command [formula] ...
Usage: #{name} [--prefix] [--cache] [--version]
Usage: #{name} [--verbose]

Commands:
  install formula ... [--debug] [--interactive]
  rm formula ...
  list formula ...
  ln formula ...
  info [formula]
  mk url
  prune
EOS
end


######################################################################## utils
def pretty_duration s
  return "#{(s*1000).to_i} milliseconds" if s < 3
  return "#{s.to_i} seconds" if s < 10*60
  return "#{(s/60).to_i} minutes"
end

######################################################################### impl
begin
  case ARGV.shift
    when '--prefix' then puts prefix
    when '--cache' then puts Homebrew::cache
    when '-h', '--help', '--usage', '-?' then puts usage
    when '-v', '--version' then puts HOMEBREW_VERSION
    when 'macports' then exec "open 'http://www.macports.org/ports.php?by=name&substr=#{ARGV.shift}'"

    when 'ls', 'list'
      dirs=extract_kegs.collect {|keg| keg.path}
      exec "find #{dirs.join' '} -not -type d -print"

    when 'edit'
      if ARGV.empty?
        exec "mate #{$formula} #{$root}/Library/Homebrew #{$root}/bin/brew #{$root}/README"
      else
        paths=extract_kegs.collect {|keg| keg.formula_path.to_s.gsub ' ', '\\ '}
        exec "mate #{paths.join ' '}"
      end

    when 'install'
      require 'formula'
      extract_named_args.each do |name|
        install Formula.create(name)
      end

    when 'ln', 'link'
      n=0
      (kegs=extract_kegs).each do |keg|
        n+=nn=keg.ln
        puts "Created #{nn} links for #{keg.name}" if kegs.length > 1
      end
      puts "Created #{n} links"

    when 'rm', 'uninstall'
      extract_kegs.each do |keg|
        puts "Removing #{keg.name}..."
        keg.rm
      end
      print "Pruning #{prefix}/..."
      puts " #{prune} symbolic links pruned"

    when 'prune'
      puts "Pruned #{prune} symbolic links"

    when 'mk', 'make'
      paths=ARGV.collect {|arg| mk arg}
      if paths.empty?
        raise "Invalid URL"
      elsif Kernel.system "which mate > /dev/null" and $? == 0
        paths=paths.collect {|path| path.to_s.gsub " ", "\\ "}
        exec "mate #{paths.join ' '}"
      else
        puts paths.join("\n")
      end

    when 'info', 'abv'
      if ARGV.empty?
        puts `ls #{$cellar} | wc -l`.strip+" kegs, "+abv
      elsif ARGV[0][0..6] == 'http://'
        puts Pathname.new(ARGV.shift).version
      else
        #TODO show outdated status and that
        keg=extract_kegs[0]
        frm=Formula.create keg.name
        puts "#{keg.name} #{keg.version}"
        puts frm.homepage
        if keg.installed?
          puts "#{abv keg} (installed to #{keg.path})"
        end
        if frm.caveats
          ohai 'Caveats'
          puts frm.caveats
        end
      end

    else
      puts usage
  end

rescue StandardError, Interrupt => e
  if ARGV.include? '--verbose' or ENV['HOMEBREW_DEBUG']
    raise
  elsif e.kind_of? Interrupt
    puts # seeimgly a newline is typical
    exit 130
  elsif e.kind_of? StandardError and not e.kind_of? NameError
    puts "\033[1;31mError\033[0;0m: #{e}"
    exit 1
  else
    raise
  end
end